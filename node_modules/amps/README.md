## AMPS JavaScript Client


##### *powerful. fast. easy.*

The AMPS JavaScript Client lets you write cross-platform messaging applications for both web apps working in a browser,
as well as server-side applications that use Node.js. It uses the power of WebSocket technology combined with
the asynchronous nature of JavaScript.
<br><br>


### Installation

The client can be installed using NPM or manually downloaded from the releases page.

```bash
npm install --save amps
```


### Quick Start

Once the client is downloaded, it can be used in your JavaScript/TypeScript projects:

**Node.js**:
```javascript
var amps = require('amps');
console.log(amps.Client.version());
```


**TypeScript**
```typescript
// NPM installation: Import everything at once
import * as amps from 'amps';
console.log(amps.Client.version());

// or

// NPM installation: This way the final bundle can be smaller
import { Client, Command } from 'amps';
console.log(Client.version());

// Manual installation (don't forget to add a typing reference):
/// <reference path="./amps.d.ts" />
import * as amps from './amps';
import { Client, Command } from './amps';
```


**Application that uses AMD modules**:
```javascript
define(['dist/amps'], function(amps) {
    console.log(amps.Client.version());
}
```


**Global import in Browser:**
```html
<!-- Optional import, provides support for obsolete browsers like IE11 -->
<script src="es6-promise.min.js"></script>
<script src="amps.js"></script>
```


You are now ready to use AMPS in your project!
Here are a few JavaScript examples to get you started:
<br><br>

#### EXAMPLE 1: CONNECT AND SUBSCRIBE

```javascript
var client = new amps.Client('my-application');

client.connect('ws://localhost:9100/amps/json')
    .then(function() {
        // Connected, let's subscribe to a topic now
        return client.subscribe(
            function(message) {
                console.log(message.data);
            }, 
            'orders'
        );
    })
    .then(function(subscriptionId) {  // Once we subscribed, the subscriptionId is passed down the chain
        console.log(subscriptionId);
        client.publish('orders', {order: 'Tesla 3', qty: 10});
    })
	.catch(function(error) {
        // This can be either a connection error or a subscription error, thanks to Promises!
        return console.log(error);
    });
```

In this example, we connect to an AMPS server running locally and initiate a subscription to the "orders" topic.
As new orders are posted, the message handler is invoked with each message, and prints the data of each order to
the console. Since every command (except publish()) returns a Promise, it is very easy to chain commands and handle
errors:
```javascript
function onMessage(message) {
    console.log('message: ', message);
}

client.connect('ws://localhost:9100/amps/json')
    .then(() => client.subscribe(onMessage, 'orders'))         // connected, subscribe for the first topic
    .then(() => client.subscribe(onMessage, 'reservations'))   // second subscription
    .then(() => client.subscribe(onMessage, 'notifications'))  // third subscription
	.catch(function(error) {
        // if any subscription failed, the chain will end up here
        return console.log(error);
    });
```
<br><br>


#### EXAMPLE 2: PUBLISH A MESSAGE

```javascript
var client = new amps.Client('publish-example');

client.connect('ws://localhost:9100/amps/xml')
    .then(function() {
        client.publish('messages', '<hi>Hello, world!</hi>');
    })
    .catch(function(err) {
        console.log(error);
    });
```

With AMPS, publishing is simple, as shown in this example. We connect to an AMPS server running locally, and publish a
single message to the `messages` topic. To simply publish a message, there is no need to predeclare the topic or
configure complex routing. Any subscription that has asked for XML messages on the `messages` topic will receive
the message.
<br><br>


#### EXAMPLE 3: DISCONNECT HANDLING

```javascript
// Assign an error handler that will handle general error such as disconnects
var client = new amps.Client('my-app').errorHandler(function(err) {
    // Error handler is only called if an error occurred after a successful connection has been established.
    console.log(err, 'Reconnecting after 5 seconds...');
    setTimeout(reconnect, 5000);
});

function reconnect() {
    return client
        .connect('wss://localhost:9100/amps/json')
        .then(onConnect)
        .catch(function(err) {
            // Connection error occurred
            setTimeout(reconnect, 5000);
        });
}

function onConnect() {
    return client
        .subscribe(function(message) {
            console.log('message: ', message);
        }, 'orders')
        .catch(function(err) {
            console.log('Subscription error: ', err);
        });
}

// Begin by connecting and subscribing
reconnect();
```

In this example, we need to be subscribed to the "orders" topic, even if connectivity to our AMPS server is temporarily 
interrupted. We use a reconnect function to enable recovery from a connection error.
When AMPS detects a connection error, the reconnect function is called from **errorHandler** to re-establish connection,
and our onConnect method subscribes to the topic again once a successful connection is made. Notice that the 
**errorHandler** is only called after a successful connection has been established, otherwise a connection error is 
caught by the `catch` callback of the **connect** Promise.
<br><br>


#### EXAMPLE 4: QUERY THE CONTENTS OF A "SOW" TOPIC

State-of-the-World ("SOW") topics in AMPS combine the power of a database table with the performance of a
publish-subscribe system. Use the AMPS JavaScript client to query the contents of a SOW topic.

```javascript
var client = new amps.Client('my-application');

client.connect('ws://localhost:9100/amps/json')
    .then(function() {
        return client.sow(
            function(message) {
                if (message.header.command() == 'sow') {
                    console.log(message.data);
                }
            },
            'orders',
            "/symbol='ROL'",
            {
                batchSize: 100,
                timeout: 5000
            }
        );
    })
	.catch(function(error) {
        console.error('Error: ', error);
	});
```

This example queries for all orders for the symbol `ROL`, and simply prints the messages to the console.
<br><br>


#### EXAMPLE 5: COMMAND INTERFACE

Even though AMPS clients provide the above named convenience methods for core AMPS functionality, 
you can use the Command object to customize the messages that AMPS sends. This is useful for more advanced
scenarios where you need precise control over the message, or in cases where you need to use an earlier version of
the client to communicate with a more recent version of AMPS, or in cases where a named method is not available.

```javascript
var client = new amps.Client('my-application');

client.connect('ws://localhost:9100/amps/json')
    .then(function() {
        var subscribeCommand = new amps.Command('subscribe')
                                   .topic('messages')
                                   .filter('/id > 20');

        return client.execute(subscribeCommand, function(message) {
            console.log('message: ', message.data);
        });
    })
    .catch(function(error) {
        console.error('Error: ', error);
    });
```

This example provides the subscription to a 'messages' topic with a filter applied.
<br><br>



### AMPS Server Configuration for Websockets

To configure AMPS for Websocket support, you need to specify the following Transport:

```html
<Transports>
    <Transport>
        <Name>json-websocket</Name>
        <Type>tcp</Type>
        <Protocol>websocket</Protocol>
        <InetAddr>9100</InetAddr>
        <MessageType>json</MessageType>
    </Transport>
</Transports>
```

With the above configuration, **AMPS** will listen for incoming Websocket connections on port **9100** and will support
the `json` message type. To use TLS/SSL, you'd specify a `Certificate` and `PrivateKey` (and optionally the Ciphers):

```html
<Transport>
    <Name>json-websocket-secure</Name>
    <Type>tcp</Type>
    <Protocol>websocket</Protocol>
    <InetAddr>9443</InetAddr>
    <MessageType>json</MessageType>
    <Certificate>./cert.pem</Certificate>
    <PrivateKey>./key.pem</PrivateKey>
    <Ciphers>HIGH:!aNULL:!MD5:@STRENGTH</Ciphers>
</Transport>
```
<br><br>



#### Authentication

Starting from **5.2.0.0**, AMPS provides a new option for websocket protocol: **WWWAuthenticate**. This option provides 
a flexible way of setting up authentication for the JavaScript client.

The option can have the following values:
* Negotiate (Kerberos)
* NTLM
* Basic realm="Secure Area" (Basic Auth)

When using **Negotiate** or **NTLM**, you don't have to do anything from the JavaScript client, it's automatically 
handled by browser/environment. In case of using **Basic Auth** (we recommend using **wss** in this scenario), you'll 
need to set a URI of the form `wss://user:password@ip:port/amps/json`.

<br>
By default, no authentication is performed until the 'logon' command is performed after connection.

<br>
In order to enable authentication for AMPS JavaScript client, you need to specify the following settings:

1. Add a protocol in the `Protocols` section of the config:
```xml
<Protocol>
    <Name>websocket-portal</Name>
    <Module>websocket</Module>
    <WWWAuthenticate>Basic realm="Secure Area"</WWWAuthenticate> <!-- Basic Auth -->
    <WWWAuthenticate>Negotiate</WWWAuthenticate> <!-- Kerberos-->
    <WWWAuthenticate>NTLM</WWWAuthenticate> <!-- NTLM -->
</Protocol>
```

2. Specify a transport in the `Transports` section of the config that will be used for the JavaScript client:
```xml
<Transport>
    <Name>websocket-auth</Name>
    <Type>tcp</Type>
    <Protocol>websocket-portal</Protocol>
    <InetAddr>9002</InetAddr>
</Transport>
```



#### EVERYTHING YOU NEED
If you need more help getting started, the 60East Technologies support and services team is ready to provide the
support you need to help you CRANK UP THE AMPS.
<br><br>
